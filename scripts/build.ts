import { Article } from "#types";
import { extract } from "https://deno.land/std@0.145.0/encoding/front_matter.ts";
import * as Marked from "https://esm.sh/marked@4.0.12";
import * as uuid from "jsr:@std/uuid";

import readDir from "#lib/readDir.ts";
import compileSSI from "#lib/ssi/compile.ts";
import { generateFeed } from "../features/feed/atom.ts";

const rawContent = await readDir("./content");
const content: Record<string, Article> = {};
const ssi: Array<string> = [];

for (const pathname in rawContent) {
  if (pathname.endsWith(".ssi.tsx")) {
    ssi.push(pathname);
    continue;
  }
}

const scripts = await compileSSI(ssi.map((name) => `./content/${name}`));

const ssiContents = `
import type { FC } from 'hono/jsx';
const SSIComponents = new Map<string,{ Component: FC, script: string }>();
${
  scripts
    ? ssi
        .map(
          (pathname, i) =>
            `SSIComponents.set("${pathname}", { Component: (await import("./${pathname}")).default, script: "${scripts[i]}" })`
        )
        .join("\n")
    : ""
}
export default SSIComponents;
`;

await Deno.writeFile("./content/ssi.ts", new TextEncoder().encode(ssiContents));

const { default: Renderer } = await import("#lib/markdown/renderer.ts");
for (const pathname in rawContent) {
  if (!pathname.endsWith(".md")) {
    continue;
  }
  try {
    const fileInfo = await Deno.stat(rawContent[pathname]);
    const contents = await Deno.readFile(rawContent[pathname]);
    const text = new TextDecoder().decode(contents);
    const data = extract<Omit<Article, "url" | "content"> & { draft: boolean }>(
      text
    );
    if (data.attrs.draft) continue;
    if (!data.attrs["id"]) {
      data.attrs.id = uuid.v1.generate();
      // Write back to file
      await Deno.writeFile(
        rawContent[pathname],
        new TextEncoder().encode(
          text.replaceAll(`\n---\n`, `\nid: "${data.attrs.id}"\n---\n`)
        )
      );
    }
    data.attrs.updatedAt = new Date(
      fileInfo.mtime || data.attrs.date
    ).toISOString();
    const article = { ...data.attrs } as Article;
    article.url = pathname.replace(/(\/index|)\.md$/, "");
    const renderer = new Renderer(article.url);
    article.content = await Marked.marked(data.body, { renderer });
    content[article.url] = article;
  } catch (error) {
    throw new Error(`${error} while parsing /content${pathname}`);
  }
}

// Write content/mod.ts
const moduleContents = `
// DO NOT EDIT. This file is generated by fresh.
// This file SHOULD be checked into source version control.
// This file is automatically updated during development when running \`dev.ts\`.

import type { Article } from "#types";
export const content:Record<string, Article> = ${JSON.stringify(content)};

export const articlesByPubDate = Object.values(content).sort(
    (a, b) => new Date(b.date).getTime() - new Date(a.date).getTime()
);

export const articlesByTag = Object.values(content).reduce((a, c) => {
    for (const tag of c.tags) {
        if (!(tag in a)) {
            a[tag] = [];
        }
        a[tag].push(c);
        a[tag].sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());
    }
    return a;
}, {} as Record<string, Article[]>);
`;
await Deno.writeFile(
  "./content/mod.ts",
  new TextEncoder().encode(moduleContents)
);

const feed = generateFeed();

await Deno.writeFile(
  "./features/feed/feed.xml",
  new TextEncoder().encode(feed)
);
